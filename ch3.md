# 1 다형성과 상속
## 다형성
* 한 객체가 여러 타입을 가질 수 있다 
* 정적 타입 언어에서는 타입 상속을 통해 구현

## 타입 상속
* 1 인터페이스 상속
  * 다중 상속을 지원하지 않는 언어에서 다형성을 구현하는 방법
  * 순수하게 타입만을 상속받는 상속
  * 인터페이스에서 정의만한 오퍼레이션을 직접 구현하는 방식으로 상속
  * 추상화를 구현하기 위한 핵심
  
* 2 구현 상속(클래스 상속)
  * 상위 클래스에 정의된 기능을 재사용하기 위한 목적 ( 재사용성이 핵심 목적)
  * 재사용성 + 다형성의 기능을 제공
  

# 2 추상타입과 유연함
## 추상화
* 추상화 != 추상타입 만들기
* 개념적 정의 : 데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정 
* 클래스를 구현할 때 하게되는 모델링 역시 추상화의 일부다
* 상세한 구현 제공 클래스들을 통해 추상타입을 이끌어내는 과정 (일반적으로 인식하고 있는 추상화)

  
## 추상타입
* 오퍼레이션의 시그니처만 제공함
* 실질적인 구현 X
* 자바의 인터페이스나 C++의 추상 메서드로만 구성된 추상 클래스를 이용해 추상타입 정의 가능 
  

## 추상타입과 실제 구현 연결
* 구현 클래스(concrete class)가 추상 타입을 상속받는 형태로 구현
* 구현 클래스에서 추상타입에서 제공한 오퍼레이션의 시그니처의 구체적인 구현 내용 제공

## 인터페이스에 대고 프로그래밍하기
* 실제 구현내용을 담고 있는 콘크리트 클래스를 통해 프로그래밍 하지 말고,  기능을 정의한 인터페이스를 통해 프로그래밍 하라
* 각 언어에서 제공하는 개념적인 인터페이스 기능을 이용해 구현
* 설계 시 인터페이스를 바로 구현하는 것이 아니라, 추후 유지보수 과정 or 구현과정에서 추상화가 필요한 부분이 나올 시 추상타입 구현후 이용 (필요에 의해 사용하라는 것이다)

 
## 추상타입의 장점
* 구현 교체의 유연함
  * 추가 요구 사항 발생시,  변화 되는 부분을 최소화 할 수 있다
  * 반복적으로 발생되는 if/else 부분 제거 가능
  * 상속 & 다형성으로 얻을 수 있는 장점을 깨지않고, 구조 확장 가능
* 공통된 개념을 도출해 중복성 제거
* 많은 책임을 가진 객체로 부터 책임을 분리해, 각 객체가 가지는 책임을 최소화하는 SRP 원칙 준수 가능
* Test 과정에서 드러나느 추상화의 장점 
  * 일반적으로 객체지향적으로 프로그램을 작성한다 할 시 팀별 or 개발자별 클래스를 나누어 개발한다 
  * 전체적인 기능을 테스트하고 싶을 때, 다른 클래스 개발이 아직 구현이 불안정하다면 일반적인 방법으로 테스트가 불가능함 
  * but 추상타입에 의해 구조가 설계되있을 경우 별도의 Mock 객체를 생성함으로 테스트가 가능해진다
  * 별도의 Mock 객체를 직접 생성하기 보다는 Mockito나 jmock 같은 프레임워크를 이용해 생성하는 것이 일반적이다.

## 추상타입 구현에서 발생할 수 있는 문제점
* 변경이 일어날 가능성이 적은 부분에 대해 인터페이스를 만들면, 구조의 복잡성만 올라가고, 유연성의 장점을 누릴 수 없는 상황이 된다
* 변경이 일어나는 부분을 정확히 캐치하여 인터페이스를 만들지 않으면, 상속 & 다형성으로 얻을 수 있는 장점이 깨질 수 있다.
