## 추상화란 ?

- [ 광범위한 ] 의미 데이터나 프로세스등 을 의미가 비슷한 개념이나 표현으로정의 하는 과정
- [ 클래스 단위 ] 클래스간의 공통점을 찾아내서 상위의 인터페이스나 클래스를 만들어내는 것
  <br></br>

## 1. 추상화는 교체에 유연

- 특정 클래스를 의존하지 않고 상위의 추상화된 인터페이스를 의존하면 교체에 있어서 유연함을 가질 수 있음
    - 유연함이란 교체에 있어서 용의하고 수정 할 코드가 적고 어디를 고쳐야할지 명확하게 들어남을 의미한다.(캡슐화와도 연결됨)
- 객체 사용 클래스에서 분기문을 제거하는 방법 -> 캡슐화하고 객체를 다형적으로 사용가능
    1. 의존성 주입
    2. Factory 패턴 사용
       <br></br>

### 추상화의 예시

#### [ 추상화 1 ] data를 얻어낼 수 있다는 공통점으로부터 ByteSource 라는 인터페이스 추출

#### [ 추상화 2 ] data를 얻어낼 수 있는 객체들을 만들어낸 다는 공통점으로 ByteSourceFactory 라는 인터페이스 추출

```
// sourceType 에 따라서 분기하지 않고 팩토리 패턴안에서 type 에 맞는 객체를 받아낸다.
// 캡슐활 실현
val source : ByteSource = ByteSourceFactory.create(sourceType)

// sourceType 과 무관하게 ByteSource 인터페이스 메서도 read를 사용하여 데이터를 얻는다.
// 추상화 및 다형성 활용
val data = source.read()

```

- ByteSource 의 종류가 추가 변경 되더라도 팩토리 클래스의 변화가 생길뿐 사용 클래스의 변화 X
    - 유지보수 편함 (수정할 위치가 산발적이지 않음)
- ByteSource 객체를 사용하고 Factory 에서 생성함
    - 책임을 세분화
      <br></br>

## 2. 추상화는 테스트에 유리

- 구현 객체가 아닌 추상 객체(인터페이스)에 의존할 때 테스트에 유리하다.
- 구현체가 완성되지 않아도 추상 객체를 의존하는 객체의 나머지 동작을 테스트 할 수 있음
    - Mock 객체 사용 혹은 관련 프레임 워크 사용(Mockito , jmock)
      <br></br>

## 3.추상화시 고려 사항

1. 교체 되는 부분을 추상클래스에 의존하면 변경에 유연하게 대처할 수 있다.
2. 변화가능성이 높은 경우에 한해서 추상화 및 인터페이스 사용
    - 추상화에 의해 타입이 증가하고 구조가 복잡해지는 코스트 발생
3. 인터페이스를 사용하는 입장에서 만들기
    - 구현체들의 공통된 특징을 잘 담을 수 있는 작명 및 구성이 필요함




