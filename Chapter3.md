## 다형성과 추상 타입

### [1]. 상속 개요

- 객체는 캡슐화를 통해서 객체를 사용하는 다른 코드에 영향을 최소화하고 객체의 내부 구현을 변경할 수 있는 유연함이 존재한다.

- 유연함을 얻을 수 있는 다른 방법은 추상화에 있다.

- `상속(Inheritance)` 은 한 타입을 그대로 사용하면서 구현을 추가할 수 있도록 해주는 방법을 제공한다.

  상속 받은 하위 클래스는 필요에 따라 상위 클래스에 정의된 메서드를 새롭게 구현할 수 있다. 이를 재정의(overriding)라 한다.

  메서드를 재정의하면, 해당 메서드를 실행할 때 상위 타입의 메서드가 아닌 하위 타입에서 재정의한 메서드가 실행된다.

---

### [2]. 다형성과 상속

- `다형성(Polymorphism)` 은 한 객체가 `여러 가지(poly)` `모습(morph)` 을 갖는다는 것을 의미한다.

  모습은 타입을 의미하며, 다형성이란 한 객체가 여러 타입을 가질 수 있는 것이다.

  <img width="777" alt="스크린샷 2022-02-05 오후 11 47 30" src="https://user-images.githubusercontent.com/66770613/152646661-5cac6d97-25ae-42ee-97b1-fa8af5dc9831.png">

#### 인터페이스 상속과 구현 상속

- 다형성을 구현하기 위해 타입을 상속받는데, 타입 상속은 `인터페이스 상속` 과 `구현 상속` 이 존재한다.

- 인터페이스 상속은 순전히 타입 정의만 상속받는 것

  클래스 구현 상속은 클래스 상속을 통해서 이루어진다. 클래스 상속은 구현을 재사용하면서 다형성도 함께 제공해준다.

- 클래스는 다중 상속 지원을 하지 않아서 인터페이스를 이용해서 객체가 다형성을 갖는다.

#### 추상 타입과 유연함

- `추상화(abstraction)` 는 데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정.

  추상화가 반드시 추상 타입을 만들어야 하는 것이 아니다.

  어플리케이션을 개발하기 위해서 필요한 부분을 찾아 내어 모델링 하는 과정 자체도 추상화가 된다.

- 구현하는 클래스에서 공통적인 부분을 이끌어내어 추상화해 인터페이스를 도출 할 수 있다.

  예를 들어, FTP에서 파일 다운로드, 소켓으로 데이터 읽기, DB 테이블에서 조회 한다고 하면 로그 수집이라는 추상화를 이끌어 낼 수 있다.

  ```kotlin
  class FtpLogFileDownloader {}
  class SocketLogReader {}
  class DbTableLogGateway {}

  interface LogCollector {
    fun collect()
  }
  ```

- 추상화된 타입은 오퍼레이션의 시그니처만 정의한다. `LogCollector` 가 추상 타입이며, 실질적인 구현을 하지 않는다.

#### 추상 타입과 실제 구현의 연결

- 각 하위 타입들은 모두 상위 타입인 `LogCollector` 인터페이스에 정의된 기능을 실제로 구현한다.

  이들 클래스들은 실제 구현을 제공한다는 의미로 `콘트리트 클래스(concrete class)` 이다.


#### 추상 타입을 이용한 구현 교체의 유연함

- 콘크리트 클래스를 직접 사용하지 않는 이유

  ```kotlin
  val reader = SocketLogReader()
  reader.collect()
  ```

  직접 사용해도 문제가 발생하지 않는다.

  요구사항으로 소켓을 통해서가 아닌 DB에서 읽어오거나 파일을 통해서 읽어오라는 요구사항이 존재한다면,

   `val reader = SocketLogReader()`  
   `val reader = FtpLogFileDownloader()` 
   `val reader = DbTableLogGateway()`
   을 직접 만들어야 한다. 그로 인해 많은 분기가 생기게 되고 복잡한 소스코드가 만들어지게 된다.

- 위의 3 경우의 수를 추상화 한 `ByteSource`  인터페이스를 이용해 `val reader: ByteSource = SocketLogReader()` 로 간단하게 표기할 수 있다.

- 추가 내용

  ByteSource 타입의 객체를 생성하는 기능을 별도 객체로 분리후, 그 객체를 사용해 ByteSource 생성할 수 있다.

  디자인 패턴의 팩토리 메서드를 활용한다. 보다 체계적인 분리가 가능하다.

  그로 인해 ByteSource의 종류가 변경되면, 팩토리 객체만 변경될 뿐이지 컨트롤러 단에서는 변경되지 않는다.  컨트롤러 단에서 제어 흐름을 변경할 때, 팩토리 객체에 영향을 주지 않는다.

#### 인터페이스에 대고 프로그래밍 하기

- 무작정 콘크리트 클래스를 사용해서 구현하는 것이 말기

  인터페이스는 오퍼레이션을 정의한 인터페이스이다. 즉, 기능을 정의한 인터페이스를 사용해서 프로그래밍해야 한다.

  추상 타입을 사용하면 기존 코드를 건드리지 않으면서 콘크리트 클래스를 교체할 수 있는 유연함을 얻을 수 있다.
  
  인터페이스는 추상화 과정을 통해서 도출된다. 추상화 과정은 변화가 발생하는 곳에서부터 시작된다.
