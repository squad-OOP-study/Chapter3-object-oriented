# chap3 다형성과 추상 타입 2022.2.6


## [배운점]
1. 인터페이스 : program to interface
2. Factory 클래스 : 객체 생성 책임을 분리하는 방법 중 하나. 보통 싱글톤으로 사용. 
3. TDD가 테스트를 강제함으로 알맞는 책임을 가진 객체를 도출하도록 유도.
  

___
## [목차]
1. 다형성 개념
2. 다형성 구현 예시
3. 변화되는 부분 추상화해서 인터페이스 도출 
4. 객체 생성 책임 분리
5. 테스트 
6. 새로운 용어 : 콘크리트 클래스
___

### 1. 다형성 개념
> 다형성  
  - 추상화를 가능하게 한다.
  - 한 객체가 여러 타입을 가질 수 있다는 것을 의미       

  <br>

  - 추상화
    - 객체 내부 구현 변경할 수 있는 유연함 제공하는 또 다른 방법
    - **데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정**
    - 타입도 추상화의 대상이 된다.     
    1. 각 구현 클래스를 추상화해서 인터페이스를 도출<br>
        (공통된 개념을 도출해서 추상 타입을 정의)
      - 그러나 추상화를 한다는 것이 반드시 추상 타입을 만들어야 하는 것은 아니다.
        - 예)  sum += mark; 
        - 코드는 CPU 일련의 처리 과정을 개념적으로 추상화한 것이다. 
    2. 많은 책임을 가진 객체로부터 책임을 분리하는 촉매제
    - 변화가 발생하는 곳부터 시작.

> 재사용
  - 상위 수준의 로직이 바뀌지 않고 재사용. 예) 흐름 제어 클래스
  - 하위 수준의 구현 재사용. 예)데이터 읽기 클래스
  - 하위 수준의 상세 구현보다는 **변하지 않는 상위 수준의 로직을 설계**하는 것이 더 중요.
  
<br>

### 2. 다형성 구현 예시
> 추상 타입을 이용한 구현 교체의 유연함
  - 예시 클래스 FlowController 
    - 책임 : 데이터 읽고 암호화해서 특정 파일에 기록    
    - 흐름 제어가 데이터 읽기 구현 변경이라는 본연과 상관없는 책임에 계속 영향 받는다.
      - 어떤 곳으로부터 바이트 데이터 읽기
      - ByteSource타입의 객체를 생성하는 부분      
    ![리스트3-3sub](https://user-images.githubusercontent.com/55780251/152666814-f187b595-7aac-4463-b1b9-61f201ab4755.jpg)
    ![리스트3-3](https://user-images.githubusercontent.com/55780251/152666816-21128100-7330-4b06-bbb6-7699c632fa06.jpg)

   
    - 변경 후 UML 
    ![그림3-8](https://user-images.githubusercontent.com/55780251/152666821-1e6b7964-6990-42c1-9d74-cd726b800361.jpg)


<br>

### 3. 인터페이스 도출 

> 변화되는 부분을 추상화
  - **추상화를 잘 하려면 다양한 상황에서 코드를 작성하고, 이 과정에서 유연한 사례를 만들어 보는 경험을 해봐야 한다.**
  - 그러나 모든 개발자가 다양한 환경에서 많은 경험을 할 수 있는 것은 아니기 때문에, **변화될 부분을 미리 예측해서 추상화**하는 것은 쉽지 않다.
  - **경험하지 않는 분야를 추상화하는 법**
    - 변화되는 부분을 추상화하기!
    - 요구사항이 바뀔 때 변화되는 부분은 이후에도 변경될 소지가 많다.
    - 이런 부분을 추상 타입으로 교체하면 향후 변경에 대처할 가능성 높아진다.
  - 추상화가 되어 있지 않은 코드는 주로 동일 구조를 갖는 if-else블록으로 드러난다.

> program to interface 
  - 객체지향의 유명한 규칙
  - interface : 오퍼레이션을 정의한 인터페이스
  - **기능을 정의한 인터페이스를 사용해서 프로그래밍하라는 뜻**
  - 주의점
    - 변화 가능성이 높은 경우에만 사용. 
    - 그렇지 않을 경우 추상타입이 증가하고 구조도 복잡해진다.
> 인터페이스 사용자 입장에서 인터페이스 만들기
  - 인터페이스를 사용하는 코드 입장에서 작성.
  - 의미를 명확하게 드러내도록 네이밍.

<br>

### 4. 객체 생성 책임 분리
> 객체 생성 책임을 분리하는 법
  1.  객체 생성 기능을 별도 객체로 분리 : Factory 클래스 
  2.  생성자나 다른 메서드를 이용해서 객체 전달 받기 : 6장 DI,서비스로케이터 

> Factory 클래스
  - 객체 생성 과정을 추상화 
  - [참고] 싱글턴 패턴
    - 인스턴스를 1개로 제한하기 위한 디자인 패턴.
    - 보통 객체 생성 하는 클래스는 인스턴스를 1 개로 제한해 사용.
  
> 작은 책임
  - 객체 생성하는 책임을 흐름 제어 하는 책임에서 분리


<br>

### 5. 테스트
> 인터페이스와 테스트
  - 인터페이스를 사용함으로 다른 클래스에 의존하지 않고 자신의 클래스를 테스트할 수 있다.
  - 인터페이스는 Mock객체를 구현하여 해결.(테스트에 사용할 데이터를 하드코딩)
  - Mock 객체를 만드는 방법 다양
    - 사용할 대상을 인터페이스로 추상화하면 좀 더 쉽게 Mock객체 만들 수 있다. 
  - 프레임워크를 이용해서 Mock객체 생성 
    - Mockito, jmock등
    - 참고url : https://javacan.tistory.com/entry/MocktestUsingMockito

___
> 용어 정리
- 콘크리트 클래스(concrete class) 
  - 실제 구현을 제공하는 클래스. 
  - 다른 책에서 종종 구상클래스로 번역되곤 하는데 저자는 의미가 일치하지 않는다고 생각
  - 참고url: https://javacan.tistory.com/253
